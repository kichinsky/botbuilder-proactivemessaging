# Proactive Bot - TypeScript Samples

## Proactive Bot - Basic Implementation

The Proactive Bot covers the following use cases:
- Send a proactive message within the same conversation.
- Broadcast a message to all live conversations from with-in chat.
- Broadcast a message to all live conversations from external endpoint.

### Prerequisites

1. This sample begins from creating a fresh new **typescript**-based **echo-bot**. For more details on how to make original setup checks this docs: [Create a bot with the Bot Framework SDK for JavaScript](https://docs.microsoft.com/en-us/azure/bot-service/javascript/bot-builder-javascript-quickstart?view=azure-bot-service-4.0).

2. To deploy the bot to the Azure Bot Service (ABS) follow the following instructions: [Deploy your bot](https://docs.microsoft.com/en-us/azure/bot-service/bot-builder-deploy-az-cli?view=azure-bot-service-4.0).

Important notes:
- Ensure you update your `<botname>.bot` file with the configuration data that you got from the ABS-generated bot. There are various strategies on how to manage encrypting, decrypting and updating the secret key. Just don't store a decrypted file in a public repository, or a repository that may eventually become public.
- Update the `botFilePath` variable in Application Settings sections on the Azure Portal to reference to your `<botname>.bot` file, if the file name differs from the one generated by the ABS.
- If you are using a CI/CD pipeline (e.g., Azure DevOps Pipeline), ensure you added a TypeScript compiling step into your pipeline. In case you are using Azure DevOps, you can add the [Compile Typescript](https://marketplace.visualstudio.com/items?itemName=bool.compile-type-script) task component from the marketplace.
- Update the `web.config` file to refer to your starting point (e.g. `app.js` in the root folder, or `index.js` in the `lib` folder).

### Store Conversation Reference

1. To continue the conversation in a distant moment in future, we have to extract and store somewhere a reference to the current conversations:
- To extract the reference we use the static function: `TurnContext.getConversationReference`.
- To temporary same the reference we create a `ConversationState` object based on a `MemoryStorage` object.

These calls are encapsulated into a new class `InMemoryConversationStorage` in the `/services/` subfolder. Implement two main methods (optionally, you can also update the state) defined in the `IConversationStorageService` interface:

*Restore or create a reference to the conversation*
```js
    public async restoreReference(context: TurnContext): Promise<ConversationReference> {
        // try extract stored reference
        let reference = await this.conversationReferenceStorage.get(context);
        // else create a new reference from the context
        if (reference === null || reference === undefined) {
            reference = TurnContext.getConversationReference(context.activity);
        }
        return reference;
    }
```

*Store a reference to the conversation*
```js
    public async storeReference(context: TurnContext): Promise<ConversationReference> {
        const reference = await this.restoreReference(context);
        await this.conversationReferenceStorage.set(context, reference);
        return Promise.resolve(reference);
    }
```

2. Create a new conversation storage object and pass it to the bot constructor (in the `index.ts`):
```js
// Create the main dialog.
const conversationStorageService = new InMemoryConversationStorage();
const myBot = new ProactiveBot(conversationStorageService);
```

And store the reference to storage in a bot property:

```js
constructor(private conversationStorageService: IConversationStorageService) {
}
```

Finally, store the reference, once the dialog is activated:
```js
        else if (context.activity.type === ActivityTypes.ConversationUpdate) {
            ...
            if (memberAdded && notBot) {
                await this.sendWelcomeMessage(context);
                // Extract the reference from the context and store in inside the storage service
                this.conversationStorageService.storeReference(context);
            }
        }
```

### Send proactive message

Next, add a method for proactive messaging inside your bot implementation. 

If you attemp to just delay sending a message, your code will fail doing it as by that moment it will lose the context of conversation:
```js
    private async sendDelayedMessage(context: TurnContext, msg: string, delay: number) {
        const echoMessage = `**Delayed**: *${msg}*`;
        const notifyMessage = `*Delayed message will come in ${delay / 1000} seconds.`;
        await context.sendActivity(notifyMessage);
        setTimeout(async () => {
            // This code fails to execute.
            await context.sendActivity(echoMessage);
        }, delay);
    }
```

Instead, we will restore the reference for active conversation and pass it to a new endpoint:
```js
    private async sendDelayedMessage(context: TurnContext, msg: string, delay: number) {
        const echoMessage = `**Delayed**: *${msg}*`;
        const notifyMessage = `*Delayed message will come in ~${delay / 1000} seconds.*`;
        await context.sendActivity(notifyMessage);
        // Restore conversation reference
        const reference = await this.conversationStorageService.restoreReference(context);
        setTimeout(async () => {
            await this.broadcastService.broadcast([reference], echoMessage);
        }, delay);
    }
```

Here we are calling the `broadcast` method of some new object `broadcastService` that we didn't add to the project so far. So let's fix it.

**Important note**
- To trigger the `sendDelayedMessage` method we updated the `onTurn` method to parse keywords from the user input.

### Add Broadcasting Service

1. Add a new broadcasting service to the project, that implements a simple broadcasting interface (`IBroadcastService`):

```js
export interface IBroadcastService {
    broadcast(references: ConversationReference[], message: string);
}
```

Our local broadcasting service is pretty simple -- it is just a wrapper around sending an http request using fetch:

```js
export class LocalBroadcastService implements IBroadcastService {
    constructor(private localEndpoint) {
    }

    public async broadcast(references: ConversationReference[], message: string) {
        const broadcastMessage = {
            message,
            references,
        };

        await fetch(this.localEndpoint, {
            body: JSON.stringify(broadcastMessage),
            headers: { "Content-Type": "application/json" },
            method: "POST",
        });
    }
}
```

2. Add the reference to broadcasting service to the bot (`index.ts`):

```js
const conversationStorageService = new InMemoryConversationStorage();
const localBroadcastEndpoint = "http://localhost:3978/api/broadcast";
const broadcastService = new LocalBroadcastService(localBroadcastEndpoint);
const myBot = new ProactiveBot(conversationStorageService, broadcastService);
```

### Add Broadcasting Endpoint

Add the broadcasting endpoint for the bot (`index.ts`):

```js
// Listen for broadcasting requests
server.post("/api/broadcast", async (req, res) => {
    const broadcastMessage = req.body;
    if (broadcastMessage !== null && broadcastMessage !== undefined) {
        const references = broadcastMessage.references;
        const message = broadcastMessage.message;
        const notifyMessage = `*Broadcasting message is comming...*`;
        await references.forEach(async (reference) => {
            // Ensure we are not calling localhost references when we are deployed to the cloud
            const localUrl = reference.serviceUrl.includes("localhost");
            const localEnv = BOT_CONFIGURATION === DEV_ENVIRONMENT;
            const matchEnv = (localEnv) || (!localEnv && !localUrl);
            if (matchEnv) {
                try {
                    // Try restore conversation
                    await adapter.continueConversation(reference, async (turnContext) => {
                        await turnContext.sendActivity(notifyMessage);
                        await turnContext.sendActivity(message);
                    });
                } catch (err) {
                    // Catch unresponsive references
                }
            }
        });
        res.send(200);
    } else {
        // No body
        res.send(204);
    }
});
```

**Important notes**:
- The endpoint accepts an array of references for future scalability (e.g., broadcast to multiple conversations).
- We are checking if the current environment is development or production (e.g., to avoid sending messages to the localhost while deployed).
- We are catching attempts to restore conversation as not all the references might be active.
- To parse the body of the request, add the body parsing plugin to restify:
```js 
server.use(restify.plugins.bodyParser());
```

---
### Middle Summary
So far we reached the point when we can type to the bot something like "delay: Hello world" and it will react to that message with 5-sec delay by sending back some message.

To do that, we extract the conversation reference and send it to the broadcasting endpoint. Here we restore the conversation and send the message to the user.
---


